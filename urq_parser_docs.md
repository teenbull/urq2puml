# URQ Parser - Алгоритм и структура данных

## Алгоритм парсинга URQ файлов

1. **Определение кодировки** - проверяет UTF-8, затем CP1251 по первым 1024 байтам

2. **Предобработка контента** (`_prep_content`):
   - Удаляет комментарии (`/* */` и `;`)
   - Убирает переносы строк (`_`)
   - Разбивает `if/then/else` конструкции на отдельные строки  
   - Делит по амперсандам (`&`)

3. **Поиск меток** - находит все строки начинающиеся с `:` (локации)

4. **Создание объектов локаций**:
   - Извлекает имя метки
   - Определяет границы контента (до следующей метки)
   - Вычисляет номер строки
   - Извлекает описание из `pln`/`p` команд
   - Помечает дубликаты

5. **Извлечение связей и флагов** для каждой локации:
   - **Автосвязь** - если нет `end` или `goto`, связывает со следующей по порядку
   - **Инлайн кнопки** - из `pln`/`p` текстов ищет `[[текст|цель]]`
   - **Явные команды** - `btn`, `goto`, `proc`
   - **Проверка циклов** - если цель = текущая локация
   - **Phantom-связи** - если цель не существует

6. **Преобразование имен целей в ID** - заменяет имена локаций на числовые ID:
   - Создает словарь имя→ID для основных локаций
   - Обрабатывает автосвязи по индексам
   - Ищет цели среди основных локаций и дубликатов
   - Помечает несуществующие цели как phantom

7. **Пометка концевых локаций** - те, из которых никто не ссылается

8. **Возврат результата** - массив локаций с преобразованными связями

**Ключевые оптимизации**: один проход по тексту для `pln`/`p`, предкомпилированные regex, кэширование уникальных текстов.

## Формат результата парсинга

**Возвращает**: список объектов `Loc`

### `locs` - список объектов `Loc`:
```python
class Loc:
    id: str          # "0", "1", "2"... (порядковый номер)
    name: str        # "start", "room1", "ending"
    desc: str        # "Вы стоите в комнате" (из pln/p команд)
    line: int        # 15 (номер строки в файле)
    dup: bool        # True если дубликат метки
    cycle: bool      # True если есть самоссылка
    end: bool        # True если концевая (никто не ссылается)
    links: []        # [(target_id, target_name, type, label, is_phantom), ...]
```

### `links` - список кортежей:
```python
# (цель_id, имя_цели, тип_связи, текст_кнопки, фантом)
("1", "room2", "btn", "Идти направо", False)      # кнопка
("0", "start", "goto", "", False)                 # goto команда  
("2", "ending", "auto", "", False)                # автосвязь
(None, "unknown", "btn", "Куда-то", True)         # phantom-связь
```

**Типы связей**: `"btn"`, `"goto"`, `"proc"`, `"auto"`

**Phantom** = `True` если цель не существует в файле

## Особенности алгоритма

### Обработка автосвязей
- Временно сохраняются как индекс следующей локации
- При преобразовании имен в ID заменяются на ID и имя следующей локации
- Создаются только если нет команд `end` или `goto`

### Обработка дубликатов
- При создании локаций проверяется счетчик имен (`name_counts`)
- Дубликаты помечаются флагом `dup = True`
- При поиске целей сначала ищутся основные локации, затем дубликаты
- Только основные локации участвуют в определении концевых

### Извлечение текста
- Приоритет: `pln` команды обрабатываются всегда, `p` только если нет `pln`
- Используется `set` для исключения повторной обработки одинаковых текстов
- Инлайн кнопки: `[[текст|цель]]` или `[[цель]]` (если текст = цель)

### Очистка текста
- Удаляются вложенные инлайн кнопки из описания и кнопок
- Кавычки заменяются на `''`
- Пустые лейблы кнопок остаются пустыми

## Дополнительная информация

### Номера строк
Номер строки локации хранится в `loc.line` и используется для вывода предупреждений о дубликатах:
```python
self._add_warning(f"Найден дубликат метки: '{name}' на строке {line_num}")
```

### Предупреждения
Парсер генерирует предупреждения для:
- Отсутствующих файлов
- Проблем с кодировкой
- Отсутствия меток в файле
- Дубликатов меток
- Пустых целей в командах